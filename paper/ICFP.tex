\documentclass[manuscript,screen,review]{acmart}

\acmConference[ICFP'25]
  {International Conference on Functional Programming}
  {October 12--18, 2025}{Singapore}

\begin{document}

\title{Bidirectional Typing for Internal Solvers Using Term Reconstruction}

\author{Pavel Sokolov}
\orcid{0009-0001-6922-2870}
\affiliation{
  \department{Faculty of Computer Science}
  \institution{National Research University Higher School of Economics}
  \city{Moscow}
  \country{Russian Federation}
}
\email{ppsokolov@hse.ru}

\author{Diana Kalinichenko}
\orcid{???}
\affiliation{
  \institution{Jane Street}
  \city{???}
  \state{???}
  \country{USA}
}
\email{dkalinichenko@janestreet.com}

\begin{abstract}
  In this talk, we present a minimal lambda calculus with dependent types and
  bidirectional type checking which would allow internal implementation of
  SMT solvers, without external script languages or meta\-programming features.
  For demonstration, we implement a solver for an equational theory of monoids.
\end{abstract}

\keywords{dependent types, bidirectional typing, partial inversion}

\maketitle

\section{Introduction}

Being able to formally verify a complex mathematical theorem or to prove that a
critical piece of software runs correctly is always a delight. However, the work
on such a task almost certainly would require to prove lots of technical lemmas
which are nigh trivial for a human mind but which computer might struggle to
solve automatically. To overcome this, either some kind of proof search is run
or specific solvers of decidable theories are employed. Here we focus on solvers
of the second kind; they are usually implemented either outside of the prover
(Coq \cite{coq}, Arend \cite{arend}) or inside but still require metaprogramming
features to work properly (Lean \cite{lean}, Agda \cite{agda}). However, it
would be much better if solvers could be written internally and without extra
machinery to allow for faster adoption of such solvers, their observability and
verifyability. Turns out that this is possible via smart application of
automatic function inversion and unification algorithms inside general
bidirectional typing discipline.

\section{Sketch of a solver}

Basic calculus is Martin-L\"of type theory with universes \cite{mltt}, a typed
lambda-calculus which can be viewed as a terse notation for proofs in
higher-order intuitionistic logic. MLTT includes \textbf{types} for formal
description of mathematical structures (which can be viewed as sets under
set-theoretical semantics) and \textbf{terms} which describe constructions of
type inhabitants (under set-theoretical semantics, terms correspond to elements
of said sets). As a logical system, MLTT is a system of natural deduction with
rules for type formation ($\Gamma \vdash \tau \; \mathrm{type}$), term
introduction and term elimination ($\Gamma \vdash t : \tau$), type equality
($\Gamma \vdash \sigma \equiv \tau$), term equality
($\Gamma \vdash t \equiv u : \tau$) and context well-formedness
($\vdash \Gamma \; \mathrm{context}$). Most notably, MLTT includes rules
necessary for declaration of inductive types (interpreted as well-founded sets),
e.g. types of a) natural numbers; b) initial segments of natural number line
$\underline{n}$; c) expressions in an algebraic signature with variables ranging
over any given type. In addition, it contains a special mechanism to treat types
as elements of special types $U_i$ called ``universes'' which we do not cover
here. All this machinery allows us to write down a general schema of an internal
solver of a decidable theory:

\begin{itemize}
  \item $F : (n : \mathbb{N}) \to \mathrm{type}$ --- a dependent type of
    formulas in a language of a theory with domain variables taken from
    $\underline{n}$;
  \item A type $\mathcal{M}$ of models of a theory;
  \item An embedding function
    \[
      P : (n : \mathbb{N}) \to (M : \mathcal{M})
          \to (\mathcal{C} : \underline{n} \to M) \to F n \to \mathrm{prop}
    \]
    which interprets formulas of a theory as internal propositions of MLTT;
  \item A dependent type of proofs of validities of formulas
    \[
      \mathrm{Prf} : (n : \mathbb{N}) \to F n \to \mathrm{type};
    \]
  \item An embedding function
    \[
      \tau : (n : \mathbb{N}) \to (M : \mathcal{M})
          \to (\mathcal{C} : \underline{n} \to M) \to (\phi : F n)
          \to \mathrm{Prf} \; n \; \phi \to P \; n \; M \; \mathcal{C} \; \phi
    \]
    which interprets proofs of validities of formulas as proofs of corresponding
    propositions of MLTT;
  \item A decision function
    \[
      \mathcal{D} : (n : \mathbb{N}) \to (\phi : F n)
          \to \left(
            \mathrm{Prf} \; n \; \phi \lor (\mathrm{Prf} \; n \; \phi \to \bot)
          \right)
    \]
    which, in fact, expresses the logic of a solver inside MLTT;
  \item A ``wrapper'' of a type
    \begin{multline*}
      (n : \mathbb{N}) \to (\phi : F n) \to (\pi : \mathrm{Prf} \; n \; \phi)
          \to (M : \mathcal{M}) \to (\mathcal{C} : \underline{n} \to M) \to\\\to
          (\mathcal{D} \; n \; \phi = \mathrm{inl} \; \pi)
          \to P \; n \; M \; \mathcal{C} \; \phi
    \end{multline*}
    The type of a wrapper is constructed in such a way that arguments can be
    provided to it iff the decision function states that a formula is, in fact,
    valid.
\end{itemize}

In order for this framework to be practical, however, we have to solve two
problems:

\begin{enumerate}
  \item A typing relation $\Gamma \vdash t : \tau$ has to be decidable;
  \item Most of the arguments (except, maybe, for $\mathcal{C}$) of a wrapper
    have to be inferred and do not have to be specified explicitly.
\end{enumerate}

To this end, we develop a special bidirectional typing system \cite{bidir} for
Martin-L\"of type theory with implicit arguments. Inference of arguments is
achieved via function inversion as in $\mathrm{Haskell}^{-1}$ \cite{haskell}
(here, we invert $P$ to infer $\phi$) and via unification algorithm embedded in
the typing relations (here, we unify $\mathcal{D} \; n \; \phi$ with
$\mathrm{inl} \; \pi$). Note that this gives rise to general inference system
which might have wider applications.

\bibliographystyle{ACM-Reference-Format}
\bibliography{bibliography}

\end{document}
