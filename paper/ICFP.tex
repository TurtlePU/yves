\documentclass[manuscript,screen,review]{acmart}
\usepackage{mathpartir}

\acmConference[ICFP'25]
  {International Conference on Functional Programming}
  {October 12--18, 2025}{Singapore}

\begin{document}

\title{Bidirectional Typing for Internal Solvers Using Term Reconstruction}

\begin{abstract}
  In this talk, we present a minimal lambda calculus with dependent types and
  bidirectional type checking which would allow internal implementation of
  SMT solvers, without external script languages or metaprogramming features.
  For demonstration, we implement a solver for an equational theory of monoids.
\end{abstract}

\keywords{dependent types, bidirectional typing, partial inversion}

\maketitle

\section{Introduction}

Being able to formally verify a complex mathematical theorem or to prove that a
critical piece of software runs correctly is always a delight. However, the work
on such a task almost certainly would require to prove lots of technical lemmas
which are nigh trivial for a human mind but which computer might struggle to
solve automatically. To overcome this, either some kind of proof search is run
or specific solvers of decidable theories are employed. Here we focus on solvers
of the second kind; they are usually implemented either outside of the prover
(Coq \cite{coq}, Arend \cite{arend}) or inside but still require metaprogramming
features to work properly (Lean \cite{lean}, Agda \cite{agda}). However, it
would be much better if solvers could be written internally and without extra
machinery to allow for faster adoption of such solvers, their observability and
verifyability. Turns out that this is possible via smart application of
automatic function inversion and unification algorithms inside general
bidirectional typing discipline.

\section{Sketch of a solver}

Basic calculus is Martin-L\"of type theory with universes \cite{mltt}, a typed
lambda-calculus which can be viewed as a terse notation for proofs in
higher-order intuitionistic logic. MLTT includes \textbf{types} for formal
description of mathematical structures (which can be viewed as sets under
set-theoretical semantics) and \textbf{terms} which describe constructions of
type inhabitants (under set-theoretical semantics, terms correspond to elements
of said sets). As a logical system, MLTT is a system of natural deduction with
rules for type formation ($\Gamma \vdash \tau \; \mathrm{type}$), term
introduction and term elimination ($\Gamma \vdash t : \tau$), type equality
($\Gamma \vdash \sigma \equiv \tau$), term equality
($\Gamma \vdash t \equiv u : \tau$) and context well-formedness
($\vdash \Gamma \; \mathrm{context}$). Most notably, MLTT includes rules
necessary for declaration of inductive types (interpreted as well-founded sets),
e.g. types of a) natural numbers; b) initial segments of natural number line
$\underline{n}$; c) expressions in an algebraic signature with variables ranging
over any given type. In addition, it contains a special mechanism to treat types
as elements of special types $U_i$ called ``universes'' which we do not cover
in this section. On the other hand, MLTT can be viewed as a total functional
programming language which allows writing down functional algorithms AND prove
their correctness in the same language. All this machinery allows us to write
down a general schema of an internal solver for some decidable theory:

\begin{itemize}
  \item Let $F : (n : \mathbb{N}) \to \mathbf{type}$ be a dependent type of
    formulas in a language of a theory with variables taken from
    $\underline{n}$;
  \item Let $\mathcal{M}$ be a type of all models of a theory;
  \item Let $P$ be an embedding function which interprets formulas of a theory
    as internal propositions of MLTT:
    \[
      P : (n : \mathbb{N}) \to (M : \mathcal{M})
          \to (\mathcal{C} : \underline{n} \to M) \to F\;n \to \mathbf{prop};
    \]
  \item Then, an \textit{internal proof} $\mathrm{Prf}$ of a formula $\phi$ is a
    proof that it holds universally, over all models and interpretations:
    \[
      \mathrm{Prf}(n:\mathbb{N})(\phi:F\;n)\coloneq
      (M:\mathcal{M})\to(\mathcal{C}:\underline{n}\to M)
      \to P\;n\;M\;\mathcal{C}\;\phi
    \]
  \item Let $\mathcal{D}$ be a decision function which, in fact, expresses the
    logic of a solver inside MLTT:
    \[
      \mathcal{D} : (n : \mathbb{N}) \to (\phi : F\;n) \to
      (\mathrm{Prf}\;n\;\phi\lor(\mathrm{Prf}\;n\;\phi\to\bot));
    \]
  \item Then, we would like to define a ``wrapper'' of a type
    \[
      (n : \mathbb{N}) \to (\phi : F n) \to (\pi : \mathrm{Prf} \; n \; \phi)
          \to (M : \mathcal{M}) \to (\mathcal{C} : \underline{n} \to M)
          \to (\mathcal{D} \; n \; \phi = \mathrm{inl} \; \pi)
          \to P \; n \; M \; \mathcal{C} \; \phi.
    \]
    The type of a wrapper is constructed in such a way that arguments can be
    provided to it iff the decision function states that a formula is, in fact,
    valid.
\end{itemize}

In order for this framework to be practical, however, we have to solve two
problems:

\begin{enumerate}
  \item A typing relation $\Gamma \vdash t : \tau$ has to be decidable;
  \item All of the wrapper's arguments (except, maybe, for $\mathcal{C}$)
    have to be inferrable from resulting type.
\end{enumerate}

To this end, we develop a special bidirectional typing system \cite{bidir} for
Martin-L\"of type theory with implicit arguments. Inference of arguments is
achieved via function inversion as in $\mathrm{Haskell}^{-1}$ \cite{haskell}
(here, we invert $P$ to infer $\phi$) and via unification algorithm embedded in
the typing relations (here, we unify $\mathcal{D} \; n \; \phi$ with
$\mathrm{inl} \; \pi$). Note that this gives rise to general inference system
which might have wider applications.

\section{The most important inference rules}

\begin{mathpar}
\inferrule[app]
  {\Gamma\vdash f\;\$\;t,\Delta:T}
  {\Gamma\vdash f\;t\;\$\;\Delta:T}
\and\inferrule[var]
  {x:U\in\Gamma\\\Gamma\vdash U\;@\;\Delta:T}
  {\Gamma\vdash x\;\$\;\Delta:T}
\and\inferrule[@-pi]
  {\Gamma;\sigma\vdash t\Leftarrow T;\tau
  \\\Gamma;\rho\vdash U[x\coloneq t]\;@\;\Delta:V;\sigma}
  {\Gamma;\rho\vdash(x:T)\to U\;@\;t,\Delta:V;\tau}
\and\inferrule[@-check]
  {\Gamma\vdash T=U\Leftarrow\mathcal{U}}
  {\Gamma\vdash T\;@\;\cdot\Leftarrow U}
\and\inferrule[@-infer]{ }{\Gamma\vdash T\;@\;\cdot\Rightarrow T}
\end{mathpar}

\section{All elaboration rules}

\begin{mathpar}
\inferrule[type]{ }{\Gamma\vdash\mathcal{U}_l\Rightarrow\mathcal{U}_{l+1}}
\and\inferrule[pi]
  {\Gamma;\sigma\vdash T\Rightarrow\mathcal{U}_{l_T};\tau
  \\\Gamma,x:T;\rho\vdash U\Rightarrow\mathcal{U}_{l_U};\sigma}
  {\Gamma;\rho\vdash(x:T)\to U\Rightarrow\mathcal{U}_{l_T\lor l_U};\tau}
\and\inferrule[abs-0]
  {\Gamma;\sigma\vdash T\Leftarrow\mathcal{U};\tau
  \\\Gamma,x:T;\rho\vdash f\Rightarrow U;\sigma}
  {\Gamma;\rho\vdash\lambda(x:T).f\Rightarrow(x:T)\to U;\tau}
\and\inferrule[pair]
  {\Gamma\vdash f\Rightarrow T\\\Gamma\vdash s\Leftarrow U[x\coloneq f]}
  {\Gamma\vdash(f,s:U)\Rightarrow(x:T)\times U}
\and\inferrule[id]
  {\Gamma\vdash t\Leftarrow T\\\Gamma\vdash u\Leftarrow T
  \\\Gamma\vdash T\Rightarrow\mathcal{U}_l}
  {\Gamma\vdash t=_T u\Rightarrow\mathcal{U}_l}
\and\inferrule[app]
  {\Gamma;\sigma\vdash f\;@\;t,\zeta\Rightarrow r;\sigma'}
  {\Gamma;\sigma\vdash f t\;@\;\zeta\Rightarrow r;\sigma'}
\and\inferrule[abs]
  {x=t:T,\Gamma;\sigma\vdash f\;@\;\zeta\Rightarrow r;\sigma'}
  {\Gamma;\sigma\vdash \lambda (x:T).f\;@\;t,\zeta\Rightarrow r;\sigma'}
\end{mathpar}

\bibliographystyle{ACM-Reference-Format}
\bibliography{bibliography}

\end{document}
